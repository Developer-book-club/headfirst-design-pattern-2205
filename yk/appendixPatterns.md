# bridge  pattern

브릿지 패턴 : **기능 클래스과 구현 클래스 계층을 분리해서 별도로 구현하여 각자 독립적으로 변형이 가능하고 확장이 가능한 패턴입니다.**

→ 다른 방식으로 인터페이스랑 구현의 다양화가 필요할때 사용합니다.

→ 즉, 구현과 기능 클래스를 의도에 따라 따로 분리한 관계에 “bridge”를 넣는것이 bridge pattern 입니다. 

# Builder pattern

빌더 패턴 : **복잡한 객체를 생성하는 방법을 정의하는 클래스와 표현하는 방법을 정의하는 클래스를 별도로 분리하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공하는 패턴입니다.**

→ 빌더 패턴은 많은 Optional한 멤버 변수(혹은 파라미터)나 지속성 없는 상태 값들에 대해 처리해야 하는 문제들을 해결합니다. 

# Chain of Responsibility

역할사슬패턴 : **한 요청을 두 개 이상의 객체에서 처리하고 싶을 때 사용하는 패턴입니다.**

→ 요청이 들어왔을때 요청을 처리하기 위한 사슬을 만들고 ,사슬속에 있는 객체들은 요청을 받아 자기 역할이면 처리하고 그렇지않으면 사슬 속 다른 객체에게 넘김니다.

→ 요청 보낸쪽,받는쪽 분리할수있습니다. 

→ 객체는 요청이 어느 흐름으로 진행되는지 알필요없습니다.

→  요청이 반드시 수행된다는 보장이없습니다.

# Flyweight

플라이웨이트패턴 : **어떤 클래스의 인스턴스 한 개만 가지고 여러 개의 “가상 인스턴스”를 제공하고 싶을 때 사용하는 패턴입니다** 

→ 이 패턴은 인스턴스를 가능한 대로 공유시켜 `new` 연산자를 통한 메모리 낭비를 줄이는 방식입니다. 

→ 인스턴스가 아주 많이 필요하지만 모두 똑같은 방식으로 제어할 수 있는 경우에 유용하게 사용됩니다

→ 특정 인스턴스만 다른 인스턴스처럼 동작하도록 하는 것이 불가능합니다.

# Interpreter

인터프리터 패턴 : **어떤 언어에 대한 인터프리터를 만들 때 사용하는 패턴입니다.언어의 규칙(문법,구문)을 정의하고 번역하기 위한 인터프리터 클래스를 기반으로 정의합니다.** 

# Mediator

미디에이터(중재자) 패턴 : **클래스 간의 복잡한 상호작용(로직)을 캡슐화하여 하나의 클래스에 위임하여 처리하는 패턴입니다.**

→ 커뮤니케이션을 하고자 하는 객체가 있을 때 서로가 커뮤니케이션 하기 복잡한 경우 이를 해결해주고 서로 간 쉽게 해주며 커플링을 약화시켜줍니다.


# Memento

메멘토 패턴 : **객체의 상태 정보를 가지는 클래스를 따로 생성하여, 객체의 상태를 저장하거나 이전 상태로 복원할 수 있게 해주는 패턴입니다**

→  원하는 시점으로 상태를 복원할수있습니다

# Prototype

프로토타입 패턴 : **객체를 생성하는 데 비용(시간과 자원)이 많이 들고, 비슷한 객체가 이미 있는 경우에 사용되는 패턴입니다.**

- 프로토타입: 대략적인 샘플

→ 객체를 복사하여 필요한 만큼 수정하여 사용합니다. Java에서는 `clone()`을 이용해 객체를 복사합니다.

# Visitor

방문자 패턴 : **방문자와 방문 공간을 분리하여, 방문 공간에 방문자가 방문할때 이후에 대한 행동을 방문자에게 위임하는 패턴입니다.**
